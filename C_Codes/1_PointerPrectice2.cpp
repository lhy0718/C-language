#include <stdio.h>

void swap(int a,int b){
	int t;
	t=a;
	a=b;
	b=t;
}

void swap2(int* a, int* b){
	int t;
	t= *a; // a의 주소에 저장된 값을 불러내는 연산자 : *  *a = a라는 주소에 저장되어 있는 값.
	*a = *b;
	*b = t; 
}

int main(){
	//int a=10;
	//int b=5;
	//printf("%d %d ",a,b);
	//swap(a,b);
	//printf("%d %d ",a,b);
	//이렇게 하면 안됨! 함수에서는 인자의 값을 받아가는 것이지, 그 자체를 가져가는 것이 아니기 때문. -> 포인터의 필요성.
	/*
	 포인터란? 
	 변수가 정해져있을 때 그 변수의 주소를 나타내는 값. 
	 어떻게 표현하느냐?   
	 int a; -> a의 주소는 &a 가 이것의 주소가 된다.  (char, double, float... 모두 동일);
	 int a[1000] -> a 자체가 배열의 포인터다. -> 정확하게는 a[0]라고하는 변수의 포인터. (배열은 주소가 연속된 변수선언, 즉 0의 위치를 알면 나머지 모두를 알게되는 것.) 
	*/
	//포인터를 이용한 바꿈 
	//swap2(&a,&b); // &연산자를 이용하여 주소를 인자로 넘겨줌.
	//printf("%d %d ",a,b);
	
	/* 포인터 변수의 연산.
	배열 a 의 주소가 a에 저장되어 있는데(a는 포인터 상수라함), 다른 포인터변수를 선언하여서 배열a의 다른 항을 출력할 수 있음 */
	int a[10]={1,2,3,4,5,6,7,8,9,10};
	int* b = a; // b가 a[0]의 주소값을 의미하게 됨.
	//printf("%d", *b);
	//printf("%d", *(b+1)); // 포인터변수에 1만큼을 더하면 다음 주소를 의미하게 됨. -> int 포인터는 4byte다음 주소. char 포인터는 1byte 다음 주소가 될 것이다.  
	int i=1;
	while (i<11){
		printf("%2d ", *b);
		b++;
		i++;
	}  	 
	
	getchar();
	return 0;
}
